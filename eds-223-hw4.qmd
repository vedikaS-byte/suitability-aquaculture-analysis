---
title: "Ocean Superfarms: Finding the Best Spots to Grow Seafood"
format: html
author: "Vedika Shirtekar" 
date: "11//2025"
format:
  pdf: 
    code-fold: false
editor: 
  markdown: 
    wrap: 72
#editor_options: 
  #chunk_output_type: console
---

# **Homework Assignment 4:** Prioritizing potential aquaculture

## Learning Outcomes

This assignment will reinforce key concepts in geospatial analysis by practicing the following:

-   combining vector/raster data

-   resampling raster data

-   masking raster data

-   map algebra

For this assignment, you are tasked with determining [which Exclusive Economic Zones (EEZ) on the West Coast of the US are best suited to developing marine aquaculture for several species of oysters ***and*** a species of your choice.]{.underline} Suitable locations will be determined based on range of suitable sea surface temperature (SST) and depth values for the species.

## Description

To make your workflow generalizable, you must create a function that has the following characteristics:

-   **arguments:**

    -   minimum and maximum sea surface temperature

    -   minimum and maximum depth

    -   species name

-   **outputs:**

    -   map of EEZ regions colored by amount of suitable area

        -   species name should be included in the map’s title

### **Prepare data**

To start, we need to load all necessary data and make sure it has the coordinate reference system.

-   shapefile for the West Coast EEZ

-   bathymetry raster

-   SST rasters

    -   combine SST rasters into a raster stack

```{r}
#| output: false
# Import packages
library(here) # Load "here" to locate and reference files
library(tidyverse) # Load the tidyverse" for data cleaning
library(sf) # Load "sf" for GIS analysis
library(raster) # Load "raster" for accessing raster data types
library(ggplot2) # Load "ggplot2" for data visualization
library(tmap) # Load "tmap" for functions to create and layer maps
library(kableExtra) # Load "kableExtra" for table formatting
library(stars) # Load "stars" for integration with "sf"
library(raster) 
library(terra) 
```

```{r}
# West Coast EEZ
eez <- vect(here::here("data", "wc_regions_clean.shp"))
```

```{r}
# Bathymetry raster
depth <- rast(here::here("data", "depth.tif"))
```

```{r}
# Create a list of the tiff files for SST
sst_years <- list.files(path="data/", # File path
                        pattern = "average_annual", # File names matching pattern
                        full.names = TRUE) # Reference entire file names matching                                             this pattern
# Stack all rasters (stack() used earlier)
sst <- rast(sst_years)
names(sst)
#class(sst)
#class(depth)
plot(sst)
```

Double check CRS

```{r}
# Create list of spatial objects
spatial_objects <- list(eez, depth, sst)

# Use eez's CRS as reference
ref_crs <- st_crs(spatial_objects$eez)
```

```{r}
# Check and transform each tile with if/else statements
if (st_crs(spatial_objects$depth) != ref_crs) {
  warning("depth CRS does not match. 
          Transforming to match eez CRS.")
  spatial_objects$depth <- st_transform(spatial_objects$depth, ref_crs)
} else {
  message("depth CRS already matches eez CRS.")
}

```

```{r}
# Check and transform each tile with if/else statements
if (st_crs(spatial_objects$sst) != ref_crs) {
  warning("sst CRS does not match. 
          Transforming to match eez CRS.")
  spatial_objects$sst <- st_transform(spatial_objects$sst, ref_crs)
} else {
  message("sst CRS already matches eez CRS.")
}

```

### **Process data**

Next, we need to process the SST and depth data so that they can be combined. In this case the SST and depth data have slightly different resolutions, extents, and positions.

-   find the mean SST from 2008-2012 (e.g. create single raster of average SST)

```{r}
# Mean sst
#sst <- project(sst, depth)
depth <- project(depth, sst)

avg_sst <- mean(sst)
plot(avg_sst)
```

-   convert average SST from Kelvin to Celsius

    -   hint: subtract by 273.15

```{r}
avg_sst <- avg_sst - 273.15
plot(avg_sst) 
```

-   crop depth raster to match the extent of the SST raster

-   note: the resolutions of the SST and depth data do not match

    -   resample the depth data to match the resolution of the SST data using the nearest neighbor approach

```{r}
# Depth has slightly different resolutions, need to resample
?resample # Use raster version
#depth_resampled <- resample(depth, sst, method = "near")
#plot(depth_resampled)
```

-   check that the depth and SST match in resolution, extent, and coordinate reference system

    -   hint: can the rasters be stacked?

```{r}
# match crs
crs(avg_sst) == crs(depth) # match


#avg_sst <- project(avg_sst, depth)

depth_sst_crop <- crop(depth, avg_sst)

depth_sst_crop <- resample(depth_sst_crop, avg_sst, method = "near")
#depth_sst_crop <- project(depth_sst_crop, avg_sst)



# Check again...
crs(avg_sst) == crs(depth) # do not match
#crs(avg_sst) == crs(depth_sst) # do not match

# Don't match, so resample
#res(avg_sst) == res(depth)

# cannot be stacked since extents do not match... after resample, crop
c(depth_sst_crop, avg_sst) 
# extent do not match... need to crop BUT after resampling
# crop first 
ext(depth) == ext(depth_sst_crop)

```

```{r}
# crop depth to sst extent
plot(depth_sst_crop)
plot(depth)
#tm_shape(depth_sst_crop) + tm_raster()
#tm_shape(depth) + tm_raster()

ext(depth_sst_crop) == ext(depth)

```

### **Find suitable locations**

To find suitable locations for marine aquaculture, we’ll need to find locations that are suitable in terms of both SST and depth.

-   reclassify SST and depth data into locations that are suitable for oysters

    -   hint: set suitable values to `1` and unsuitable values to `0`

```{r}
# preferred range: 
#sea surface temperature: 11-30°C

## reclassify avg_sst
# reclass matrix 
reclass_matrix_sst <- matrix(
  c(-Inf, 11, 0,
    11, 30, 1, 
    30, Inf, 0),
  ncol = 3, 
  byrow = T
)

avg_sst_reclass <- classify(avg_sst, rcl = reclass_matrix_sst)

plot(avg_sst_reclass)

# create a raster mask? suitable vs unsuitable?



```

```{r}
## Now, reclassify depth

#depth: 0-70 meters below sea level

# reclass matrix 
reclass_matrix_depth <- matrix(
  c(-Inf, -70, 0,
    -70, 0, 1, 
    0, Inf, 0),
  ncol = 3, 
  byrow = T
)

depth_reclass <- classify(depth_sst_crop, rcl = reclass_matrix_depth)
plot(depth_reclass)

# make sure extent match
```

-   find locations that satisfy both SST and depth conditions

```{r}
# crop extent? 
# crs(depth) == crs(avg_sst)
# 
# 
# ext(depth) == ext(avg_sst)

# can they be stacked?
c(depth_reclass, avg_sst_reclass)
crs(depth_reclass) == crs(avg_sst_reclass)

# need to find BOTH locations... need to filter for suitable locations then join?
# suitable areas with raster multiplication
?lapp

#lapp(x = c(avg_sst_reclass,depth_reclass), fun = func(x,y) retunx*y)
multiply <- function(x,y){ 
  multi_raster <- x*y
  return(multi_raster)
  }

avg_sst_depth <- lapp(x = c(avg_sst_reclass,depth_reclass), fun = multiply)
plot(avg_sst_depth)

view(avg_sst_depth)
#tm_shape(avg_sst_depth) + tm_raster()
res(avg_sst_reclass) == res(depth_reclass)


```

### **Determine the most suitable EEZ**

We want to determine the total suitable area within each EEZ in order to rank zones by priority. To do so, we need to find the total area of suitable locations within each EEZ.

-   select suitable cells within West Coast EEZs

-   find area of grid cells

-   find the total suitable area within each EEZ

    -   hint: it might be helpful to rasterize the EEZ data

```{r}
## suitable cells within west coast eezs
# Note: eez is an sf.. convert to terra?
#eez_vect <- vect(eez)

#plot(eez)
crs(eez) == crs(avg_sst_depth) # not match, reproject
eez <- project(eez, avg_sst_depth)
crs(eez) == crs(avg_sst_depth) # now match, reproject


avg_sst_depth_suitable <- ifel(avg_sst_depth == 0, NA, 1)

plot(avg_sst_depth_suitable)


crs(eez) == crs(avg_sst_depth_suitable) 



```

```{r}

plot(mask(avg_sst_depth_suitable, eez))

suitable_cells_eez <-  mask(avg_sst_depth_suitable, eez)
suitable_cells_eez
# inherited method not found, need to do spatvector recognition for polygons
?extract 
eez
tm_shape(eez) + tm_polygons(fill = "rgn")+ tm_shape(suitable_cells_eez) + tm_raster() 
```
